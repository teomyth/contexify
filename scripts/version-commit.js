#!/usr/bin/env node

/**
 * Version commit script
 *
 * This script is specifically designed to commit changes after a version update.
 * It verifies that the changes are related to versioning (package.json, CHANGELOG.md files)
 * before committing them.
 *
 * The script handles two scenarios:
 * 1. When Changesets is configured with `commit: false` -commits all version-related changes
 * 2. When Changesets is configured with `commit: true` -only commits additional changes from version sync
 *
 * Note: This script uses the `--no-verify` option when committing to skip Git hooks,
 * as version-related changes don't need code formatting or linting checks.
 *
 * Typical usage:
 * -Automatically executed after `pnpm version` via postversion hook
 * -Can be manually run with `pnpm version-commit` after version changes
 */

import { execSync } from 'child_process';
import fs from 'fs';
import path from 'path';

// Define the commit message constant
// All submission messages are defined here for unified management and modification
const COMMIT_MESSAGES = {
  // When Changesets is configured to commit: false, messages for all version-related changes are submitted
  VERSION_ALL: 'chore: update versions and CHANGELOG.md files',

  // When Changesets is configured to commit: true, only messages of changes generated by source version synchronization are submitted
  VERSION_SYNC_ONLY: 'chore: sync version constants in source files',

  // To add a new commit message type, define it here and use COMMIT_MESSAGES.YOUR_NEW_TYPE in your code
  // For example: DEPENDENCY_UPDATE: 'chore: update dependencies',
};

// Execute the git command and return the output
function exec(command) {
  try {
    return execSync(command, { encoding: 'UTF8' }).trim();
  } catch (error) {
    console.error(`The command execution failed: ${command}`);
    console.error(error.message);
    process.exit(1);
  }
}

// Commit changes with the specified message
function commitChanges(message) {
  // Add all changes
  exec('git add .');

  // Commit changes, skip hooks with --no-verify
  exec(`git commit -m "${message}" --no-verify`);

  console.log(`Changes have been committed successfully with message: "${message}"`);
}

// Check for uncommitted changes
function getChanges() {
  const status = exec('git status --porcelain');
  return status;
}

// File patterns for version-related files
const FILE_PATTERNS = {
  PACKAGE_JSON: /package\.json$/,
  CHANGELOG: /CHANGELOG\.md$/,
  CHANGESET: /\.changeset\/.*$/,
  SOURCE_VERSION: /src\/version\.(js|ts)$/
};

// Check if changes match specific patterns
function checkChanges(changes, patterns) {
  const lines = changes.split('\n').filter(line => line.trim());

  return lines.some(line => {
    const file = line.substring(3); // Skip status marks and spaces
    return patterns.some(pattern => pattern.test(file));
  });
}

// Check if changes are version-related
function hasVersionChanges(changes) {
  // All version-related patterns
  const patterns = [
    FILE_PATTERNS.PACKAGE_JSON,
    FILE_PATTERNS.CHANGELOG,
    FILE_PATTERNS.CHANGESET,
    FILE_PATTERNS.SOURCE_VERSION
  ];

  return checkChanges(changes, patterns);
}

// Check if only source version files were changed (sync:version result)
function hasOnlySourceVersionChanges(changes) {
  // Check if there are source version file changes
  const hasSourceVersionChanges = checkChanges(changes, [FILE_PATTERNS.SOURCE_VERSION]);

  // Check if there are other version-related changes
  const otherPatterns = [
    FILE_PATTERNS.PACKAGE_JSON,
    FILE_PATTERNS.CHANGELOG,
    FILE_PATTERNS.CHANGESET
  ];
  const hasOtherChanges = checkChanges(changes, otherPatterns);

  // Return true if there are source version changes but no other changes
  return hasSourceVersionChanges && !hasOtherChanges;
}

// Check if Changesets is configured with commit: true
function isChangesetCommitEnabled() {
  try {
    const configPath = path.resolve(process.cwd(), '.changeset/config.json');
    if (fs.existsSync(configPath)) {
      const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
      return config.commit === true;
    }
    return false;
  } catch (error) {
    console.error('Error reading Changesets config:', error.message);
    return false;
  }
}

// Main function
function main() {
  console.log('Checking for version-related changes...');

  const changes = getChanges();

  if (!changes) {
    console.log('No changes detected, nothing to commit.');
    return;
  }

  // Check if Changesets is configured to commit changes
  const changesetCommitEnabled = isChangesetCommitEnabled();

  if (changesetCommitEnabled) {
    // If Changesets is already committing changes, we only need to commit source version changes
    if (hasOnlySourceVersionChanges(changes)) {
      console.log('Only source version changes detected after Changesets commit.');

      // Commit only the version sync changes
      commitChanges(COMMIT_MESSAGES.VERSION_SYNC_ONLY);
    } else {
      console.log('Changesets is configured to commit changes automatically.');
      console.log('No additional source-only changes detected. Nothing to commit.');
    }
    return;
  }

  // Standard flow when Changesets is not committing changes
  if (!hasVersionChanges(changes)) {
    console.log('No version-related changes detected. Skipping commit.');
    return;
  }

  console.log('Version-related changes detected, preparing to commit...');

  // Commit all version-related changes
  commitChanges(COMMIT_MESSAGES.VERSION_ALL);
}

// Execute the main function
main();
