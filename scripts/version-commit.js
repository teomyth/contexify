#!/usr/bin/env node

/**
 * Version commit script
 *
 * This script is specifically designed to commit changes after a version update.
 * It verifies that the changes are related to versioning (package.json, CHANGELOG.md files)
 * before committing them.
 *
 * The script handles two scenarios:
 * 1. When Changesets is configured with `commit: false` -commits all version-related changes
 * 2. When Changesets is configured with `commit: true` -only commits additional changes from version sync
 *
 * Typical usage:
 * -Automatically executed after `pnpm version` via postversion hook
 * -Can be manually run with `pnpm version-commit` after version changes
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

// Define the commit message constant
// All submission messages are defined here for unified management and modification
const COMMIT_MESSAGES = {
  // When Changesets is configured to commit: false, messages for all version-related changes are submitted
  VERSION_ALL: 'chore: update versions and CHANGELOG.md files',

  // When Changesets is configured to commit: true, only messages of changes generated by source version synchronization are submitted
  VERSION_SYNC_ONLY: 'chore: sync version constants in source files',

  // To add a new commit message type, define it here and use COMMIT_MESSAGES.YOUR_NEW_TYPE in your code
  // For example: DEPENDENCY_UPDATE: 'chore: update dependencies',
};

// Execute the git command and return the output
function exec(command) {
  try {
    return execSync(command, { encoding: 'UTF8' }).trim();
  } catch (error) {
    console.error(`The command execution failed: ${command}`);
    console.error(error.message);
    process.exit(1);
  }
}

// Check for uncommitted changes
function getChanges() {
  const status = exec('git status --porcelain');
  return status;
}

// Check if changes are version-related
function hasVersionChanges(changes) {
  // Check for changes to package.json or CHANGELOG.md files
  const versionRelatedPatterns = [
    /package\.json$/,      // package.json file
    /CHANGELOG\.md$/,     // CHANGELOG.md file
    /\.changeset\/.*$/,  // Files in the .changeset directory
    /src\/version\.(js|ts)$/  // Version-related source files
  ];

  const lines = changes.split('\n').filter(line => line.trim());

  return lines.some(line => {
    const file = line.substring(3); // Skip status marks and spaces
    return versionRelatedPatterns.some(pattern => pattern.test(file));
  });
}

// Check if only source version files were changed (sync:version result)
function hasOnlySourceVersionChanges(changes) {
  const sourceVersionPattern = /src\/version\.(js|ts)$/;
  const packageJsonPattern = /package\.json$/;
  const changelogPattern = /CHANGELOG\.md$/;
  const changesetPattern = /\.changeset\/.*$/;

  const lines = changes.split('\n').filter(line => line.trim());

  // Check if there are only source version file changes
  const hasSourceVersionChanges = lines.some(line => {
    const file = line.substring(3); // Skip status marks and spaces
    return sourceVersionPattern.test(file);
  });

  // Check if there are no package.json, CHANGELOG.md, or .changeset changes
  const hasOtherChanges = lines.some(line => {
    const file = line.substring(3); // Skip status marks and spaces
    return packageJsonPattern.test(file) ||
           changelogPattern.test(file) ||
           changesetPattern.test(file);
  });

  // Return true if there are source version changes but no other changes
  return hasSourceVersionChanges && !hasOtherChanges;
}

// Check if Changesets is configured with commit: true
function isChangesetCommitEnabled() {
  try {
    const configPath = path.resolve(process.cwd(), '.changeset/config.json');
    if (fs.existsSync(configPath)) {
      const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
      return config.commit === true;
    }
    return false;
  } catch (error) {
    console.error('Error reading Changesets config:', error.message);
    return false;
  }
}

// Main function
function main() {
  console.log('Checking for version-related changes...');

  const changes = getChanges();

  if (!changes) {
    console.log('No changes detected, nothing to commit.');
    return;
  }

  // Check if Changesets is configured to commit changes
  const changesetCommitEnabled = isChangesetCommitEnabled();

  if (changesetCommitEnabled) {
    // If Changesets is already committing changes, we only need to commit source version changes
    if (hasOnlySourceVersionChanges(changes)) {
      console.log('Only source version changes detected after Changesets commit.');
      console.log(`Committing these additional changes with message: "${COMMIT_MESSAGES.VERSION_SYNC_ONLY}"...`);

      // Add all changes
      exec('git add .');

      // Commit only the version sync changes
      exec(`git commit -m "${COMMIT_MESSAGES.VERSION_SYNC_ONLY}"`);

      console.log('Source version changes have been committed successfully.');
    } else {
      console.log('Changesets is configured to commit changes automatically.');
      console.log('No additional source-only changes detected. Nothing to commit.');
    }
    return;
  }

  // Standard flow when Changesets is not committing changes
  if (!hasVersionChanges(changes)) {
    console.log('No version-related changes detected. Skipping commit.');
    return;
  }

  console.log('Version-related changes detected, preparing to commit...');
  console.log(`Using commit message: "${COMMIT_MESSAGES.VERSION_ALL}"...`);

  // Add all changes
  exec('git add .');

  // Commit changes
  exec(`git commit -m "${COMMIT_MESSAGES.VERSION_ALL}"`);

  console.log('Version changes have been committed successfully.');
}

// Execute the main function
main();
