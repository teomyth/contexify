"use strict";(self.webpackChunk_contexify_docs_site=self.webpackChunk_contexify_docs_site||[]).push([[118],{8162:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>c,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"guides/testing","title":"Testing Guide","description":"This guide provides instructions for testing applications built with Contexify.","source":"@site/docs/guides/testing.md","sourceDirName":"guides","slug":"/guides/testing","permalink":"/contexify/docs/guides/testing","draft":false,"unlisted":false,"editUrl":"https://github.com/teomyth/contexify/edit/main/docs-site/docs/guides/testing.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Component Creation Guide","permalink":"/contexify/docs/guides/component-creation"},"next":{"title":"Documentation Development Guide","permalink":"/contexify/docs/guides/documentation"}}');var r=n(7968),o=n(9880);const i={sidebar_position:3},c="Testing Guide",a={},l=[{value:"Overview",id:"overview",level:2},{value:"Types of Tests",id:"types-of-tests",level:2},{value:"Unit Testing",id:"unit-testing",level:2},{value:"Testing Services",id:"testing-services",level:3},{value:"Testing Controllers",id:"testing-controllers",level:3},{value:"Integration Testing",id:"integration-testing",level:2},{value:"End-to-End Testing",id:"end-to-end-testing",level:2},{value:"Testing Components",id:"testing-components",level:2},{value:"Testing Interceptors",id:"testing-interceptors",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"testing-guide",children:"Testing Guide"})}),"\n",(0,r.jsx)(t.p,{children:"This guide provides instructions for testing applications built with Contexify."}),"\n",(0,r.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(t.p,{children:"Testing is an essential part of software development. Contexify's dependency injection system makes it easy to test your application by allowing you to mock dependencies."}),"\n",(0,r.jsx)(t.h2,{id:"types-of-tests",children:"Types of Tests"}),"\n",(0,r.jsx)(t.p,{children:"When testing a Contexify application, you'll typically write the following types of tests:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Unit Tests"}),": Test individual classes or functions in isolation"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Integration Tests"}),": Test how multiple components work together"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"End-to-End Tests"}),": Test the entire application from the user's perspective"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"unit-testing",children:"Unit Testing"}),"\n",(0,r.jsx)(t.p,{children:"Unit tests focus on testing a single unit of code in isolation. In Contexify applications, this typically means testing a single class or function."}),"\n",(0,r.jsx)(t.h3,{id:"testing-services",children:"Testing Services"}),"\n",(0,r.jsx)(t.p,{children:"Here's an example of testing a service:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"import { Context } from 'contexify';\nimport { UserService } from '../services/user.service';\nimport { UserRepository } from '../repositories/user.repository';\n\ndescribe('UserService', () => {\n  let context: Context;\n  let userService: UserService;\n  let mockUserRepository: jest.Mocked<UserRepository>;\n\n  beforeEach(() => {\n    // Create a mock repository\n    mockUserRepository = {\n      findById: jest.fn(),\n      create: jest.fn(),\n    } as unknown as jest.Mocked<UserRepository>;\n\n    // Create a context\n    context = new Context('test');\n\n    // Bind the mock repository\n    context.bind('repositories.UserRepository').to(mockUserRepository);\n\n    // Bind the service\n    context.bind('services.UserService').toClass(UserService);\n  });\n\n  it('should get a user by id', async () => {\n    // Arrange\n    const userId = '123';\n    const expectedUser = { id: userId, name: 'John Doe' };\n    mockUserRepository.findById.mockResolvedValue(expectedUser);\n\n    // Act\n    userService = await context.get('services.UserService');\n    const user = await userService.getUser(userId);\n\n    // Assert\n    expect(mockUserRepository.findById).toHaveBeenCalledWith(userId);\n    expect(user).toEqual(expectedUser);\n  });\n\n  it('should create a user', async () => {\n    // Arrange\n    const userData = { name: 'John Doe' };\n    const expectedUser = { id: '123', ...userData };\n    mockUserRepository.create.mockResolvedValue(expectedUser);\n\n    // Act\n    userService = await context.get('services.UserService');\n    const user = await userService.createUser(userData);\n\n    // Assert\n    expect(mockUserRepository.create).toHaveBeenCalledWith(userData);\n    expect(user).toEqual(expectedUser);\n  });\n});\n"})}),"\n",(0,r.jsx)(t.h3,{id:"testing-controllers",children:"Testing Controllers"}),"\n",(0,r.jsx)(t.p,{children:"Here's an example of testing a controller:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"import { Context } from 'contexify';\nimport { UserController } from '../controllers/user.controller';\nimport { UserService } from '../services/user.service';\n\ndescribe('UserController', () => {\n  let context: Context;\n  let userController: UserController;\n  let mockUserService: jest.Mocked<UserService>;\n\n  beforeEach(() => {\n    // Create a mock service\n    mockUserService = {\n      getUser: jest.fn(),\n      createUser: jest.fn(),\n    } as unknown as jest.Mocked<UserService>;\n\n    // Create a context\n    context = new Context('test');\n\n    // Bind the mock service\n    context.bind('services.UserService').to(mockUserService);\n\n    // Bind the controller\n    context.bind('controllers.UserController').toClass(UserController);\n  });\n\n  it('should get a user by id', async () => {\n    // Arrange\n    const userId = '123';\n    const expectedUser = { id: userId, name: 'John Doe' };\n    mockUserService.getUser.mockResolvedValue(expectedUser);\n\n    // Act\n    userController = await context.get('controllers.UserController');\n    const user = await userController.getUser(userId);\n\n    // Assert\n    expect(mockUserService.getUser).toHaveBeenCalledWith(userId);\n    expect(user).toEqual(expectedUser);\n  });\n\n  it('should create a user', async () => {\n    // Arrange\n    const userData = { name: 'John Doe' };\n    const expectedUser = { id: '123', ...userData };\n    mockUserService.createUser.mockResolvedValue(expectedUser);\n\n    // Act\n    userController = await context.get('controllers.UserController');\n    const user = await userController.createUser(userData);\n\n    // Assert\n    expect(mockUserService.createUser).toHaveBeenCalledWith(userData);\n    expect(user).toEqual(expectedUser);\n  });\n});\n"})}),"\n",(0,r.jsx)(t.h2,{id:"integration-testing",children:"Integration Testing"}),"\n",(0,r.jsx)(t.p,{children:"Integration tests focus on testing how multiple components work together. In Contexify applications, this typically means testing how services, repositories, and other components interact."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"import { Context } from 'contexify';\nimport { UserService } from '../services/user.service';\nimport { UserRepository } from '../repositories/user.repository';\nimport { DatabaseService } from '../services/database.service';\n\ndescribe('User Integration', () => {\n  let context: Context;\n  let userService: UserService;\n  let databaseService: DatabaseService;\n\n  beforeEach(async () => {\n    // Create a context\n    context = new Context('test');\n\n    // Bind the database service\n    context.bind('services.DatabaseService').toClass(DatabaseService);\n\n    // Bind the repository\n    context.bind('repositories.UserRepository').toClass(UserRepository);\n\n    // Bind the service\n    context.bind('services.UserService').toClass(UserService);\n\n    // Get the database service\n    databaseService = await context.get('services.DatabaseService');\n\n    // Initialize the database\n    await databaseService.initialize();\n\n    // Get the user service\n    userService = await context.get('services.UserService');\n  });\n\n  afterEach(async () => {\n    // Clean up the database\n    await databaseService.cleanup();\n  });\n\n  it('should create and retrieve a user', async () => {\n    // Create a user\n    const userData = { name: 'John Doe' };\n    const createdUser = await userService.createUser(userData);\n\n    // Retrieve the user\n    const retrievedUser = await userService.getUser(createdUser.id);\n\n    // Assert\n    expect(retrievedUser).toEqual(createdUser);\n  });\n});\n"})}),"\n",(0,r.jsx)(t.h2,{id:"end-to-end-testing",children:"End-to-End Testing"}),"\n",(0,r.jsx)(t.p,{children:"End-to-end tests focus on testing the entire application from the user's perspective. In Contexify applications, this typically means testing the API endpoints or user interface."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"import { Application } from '../application';\nimport axios from 'axios';\n\ndescribe('User API', () => {\n  let app: Application;\n  let baseUrl: string;\n\n  beforeAll(async () => {\n    // Create and start the application\n    app = new Application();\n    await app.start();\n\n    // Get the base URL\n    const port = app.getSync('config.port');\n    baseUrl = `http://localhost:${port}`;\n  });\n\n  afterAll(async () => {\n    // Stop the application\n    await app.stop();\n  });\n\n  it('should create a user', async () => {\n    // Create a user\n    const userData = { name: 'John Doe' };\n    const response = await axios.post(`${baseUrl}/users`, userData);\n\n    // Assert\n    expect(response.status).toBe(201);\n    expect(response.data).toHaveProperty('id');\n    expect(response.data.name).toBe(userData.name);\n  });\n\n  it('should get a user by id', async () => {\n    // Create a user\n    const userData = { name: 'Jane Doe' };\n    const createResponse = await axios.post(`${baseUrl}/users`, userData);\n    const userId = createResponse.data.id;\n\n    // Get the user\n    const getResponse = await axios.get(`${baseUrl}/users/${userId}`);\n\n    // Assert\n    expect(getResponse.status).toBe(200);\n    expect(getResponse.data).toEqual(createResponse.data);\n  });\n});\n"})}),"\n",(0,r.jsx)(t.h2,{id:"testing-components",children:"Testing Components"}),"\n",(0,r.jsx)(t.p,{children:"When testing components, you'll typically test how the component integrates with the application."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"import { Context } from 'contexify';\nimport { LoggerComponent, LoggerBindings, Logger } from '../components/logger';\n\ndescribe('LoggerComponent', () => {\n  let context: Context;\n  let logger: Logger;\n\n  beforeEach(async () => {\n    // Create a context\n    context = new Context('test');\n\n    // Add the logger component\n    const loggerComponent = new LoggerComponent({ level: 'debug', prefix: 'Test' });\n    for (const binding of loggerComponent.bindings) {\n      context.add(binding);\n    }\n\n    // Get the logger\n    logger = await context.get(LoggerBindings.SERVICE);\n  });\n\n  it('should log messages', () => {\n    // Mock console methods\n    const consoleSpy = jest.spyOn(console, 'info').mockImplementation();\n\n    // Log a message\n    logger.info('Test message');\n\n    // Assert\n    expect(consoleSpy).toHaveBeenCalledWith('[Test] Test message');\n\n    // Restore console methods\n    consoleSpy.mockRestore();\n  });\n});\n"})}),"\n",(0,r.jsx)(t.h2,{id:"testing-interceptors",children:"Testing Interceptors"}),"\n",(0,r.jsx)(t.p,{children:"When testing interceptors, you'll typically test how they modify method behavior."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"import { Context, intercept, injectable } from 'contexify';\nimport { LogInterceptor } from '../interceptors/log.interceptor';\n\n// Create a test class with an intercepted method\n@injectable()\nclass TestService {\n  @intercept(LogInterceptor)\n  async testMethod(arg1: string, arg2: number): Promise<string> {\n    return `${arg1}-${arg2}`;\n  }\n}\n\ndescribe('LogInterceptor', () => {\n  let context: Context;\n  let testService: TestService;\n\n  beforeEach(async () => {\n    // Create a context\n    context = new Context('test');\n\n    // Bind the test service\n    context.bind('services.TestService').toClass(TestService);\n\n    // Get the test service\n    testService = await context.get('services.TestService');\n  });\n\n  it('should log method calls', async () => {\n    // Mock console methods\n    const consoleSpy = jest.spyOn(console, 'log').mockImplementation();\n\n    // Call the intercepted method\n    const result = await testService.testMethod('hello', 123);\n\n    // Assert\n    expect(result).toBe('hello-123');\n    expect(consoleSpy).toHaveBeenCalledWith('Calling method: testMethod');\n    expect(consoleSpy).toHaveBeenCalledWith(\n      'Method testMethod returned:',\n      'hello-123'\n    );\n\n    // Restore console methods\n    consoleSpy.mockRestore();\n  });\n});\n"})}),"\n",(0,r.jsx)(t.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Isolate Tests"}),": Each test should be independent of others"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Mock Dependencies"}),": Use mocks to isolate the code being tested"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Test Edge Cases"}),": Test error conditions and edge cases"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Use Test Doubles"}),": Use spies, stubs, and mocks as needed"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Clean Up"}),": Clean up resources after tests"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Use Test Fixtures"}),": Use fixtures to set up test data"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Test Coverage"}),": Aim for high test coverage"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Continuous Integration"}),": Run tests automatically on code changes"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsx)(t.p,{children:"Now that you understand how to test your application, you can learn about:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"./application-structure",children:"Application Structure"})," - How to structure your application"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"./component-creation",children:"Component Creation"})," - How to create reusable components"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"../category/core-concepts",children:"Core Concepts"})," - Learn about the core concepts of Contexify"]}),"\n"]})]})}function p(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},9880:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>c});var s=n(4700);const r={},o=s.createContext(r);function i(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);