"use strict";(self.webpackChunk_contexify_docs_site=self.webpackChunk_contexify_docs_site||[]).push([[864],{991:(e,n,i)=>{i.d(n,{R:()=>c,x:()=>r});var t=i(4700);const s={},o=t.createContext(s);function c(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),t.createElement(o.Provider,{value:n},e.children)}},6775:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>p,frontMatter:()=>c,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"best-practices","title":"Best Practices","description":"This document provides best practices for using the Context system in the Contexify framework, referencing design concepts and practical experience from the LoopBack framework.","source":"@site/docs/best-practices.md","sourceDirName":".","slug":"/best-practices","permalink":"/contexify/docs/best-practices","draft":false,"unlisted":false,"editUrl":"https://github.com/teomyth/contexify/edit/main/docs-site/docs/best-practices.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Documentation Development Guide","permalink":"/contexify/docs/guides/documentation"},"next":{"title":"API Reference","permalink":"/contexify/docs/category/api-reference"}}');var s=i(7968),o=i(991);const c={sidebar_position:4},r="Best Practices",a={},l=[{value:"Context Usage Patterns",id:"context-usage-patterns",level:2},{value:"Not Recommended: Global Context Object",id:"not-recommended-global-context-object",level:3},{value:"Not Recommended: Context as a Parameter",id:"not-recommended-context-as-a-parameter",level:3},{value:"Recommended: Extending Context to Create a Domain-Specific Application Core",id:"recommended-extending-context-to-create-a-domain-specific-application-core",level:3},{value:"Application Architecture",id:"application-architecture",level:2},{value:"Application Class Extending Context",id:"application-class-extending-context",level:3},{value:"Components and Modular Design",id:"components-and-modular-design",level:3},{value:"Lifecycle Management",id:"lifecycle-management",level:3},{value:"Dependency Injection Best Practices",id:"dependency-injection-best-practices",level:2},{value:"Use Decorators for Dependency Injection",id:"use-decorators-for-dependency-injection",level:3},{value:"Binding Key Naming Conventions",id:"binding-key-naming-conventions",level:3},{value:"Scope Management",id:"scope-management",level:3},{value:"Advanced Patterns",id:"advanced-patterns",level:2},{value:"Using Interceptors",id:"using-interceptors",level:3},{value:"Using the Observer Pattern",id:"using-the-observer-pattern",level:3},{value:"Configuration Management",id:"configuration-management",level:3},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"best-practices",children:"Best Practices"})}),"\n",(0,s.jsx)(n.p,{children:"This document provides best practices for using the Context system in the Contexify framework, referencing design concepts and practical experience from the LoopBack framework."}),"\n",(0,s.jsx)(n.h2,{id:"context-usage-patterns",children:"Context Usage Patterns"}),"\n",(0,s.jsx)(n.p,{children:"When using Context, there are several common patterns. Below is an analysis of these patterns and recommended best practices."}),"\n",(0,s.jsx)(n.h3,{id:"not-recommended-global-context-object",children:"Not Recommended: Global Context Object"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Not recommended pattern\nconst globalContext = new Context();\nglobalContext.bind('service').toClass(MyService);\n\n// Anywhere in the application\nconst service = globalContext.getSync('service');\nservice.doSomething();\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problems"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Creates global state, making it difficult to test and manage"}),"\n",(0,s.jsx)(n.li,{children:"Hides dependencies, making code harder to understand and maintain"}),"\n",(0,s.jsx)(n.li,{children:"Cannot easily replace or mock dependencies for testing"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"not-recommended-context-as-a-parameter",children:"Not Recommended: Context as a Parameter"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Not recommended pattern\nfunction doSomething(context: Context) {\n  const service = context.getSync('service');\n  service.doSomething();\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problems"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Still hides the actual dependencies"}),"\n",(0,s.jsx)(n.li,{children:"Makes the function dependent on the Context API rather than the services it actually needs"}),"\n",(0,s.jsx)(n.li,{children:"Difficult to test because you need to create and configure a Context"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"recommended-extending-context-to-create-a-domain-specific-application-core",children:"Recommended: Extending Context to Create a Domain-Specific Application Core"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Recommended pattern\nexport class MyApplication extends Context {\n  constructor() {\n    super('application');\n    this.bind('service').toClass(MyService);\n  }\n}\n\n// Using the application class\nconst app = new MyApplication();\napp.start();\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The application itself is a Context, providing clear architectural boundaries"}),"\n",(0,s.jsx)(n.li,{children:"Components can get their dependencies through dependency injection"}),"\n",(0,s.jsx)(n.li,{children:"Easy to test because dependencies can be mocked or replaced"}),"\n",(0,s.jsx)(n.li,{children:"Supports modular design and extensibility"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"application-architecture",children:"Application Architecture"}),"\n",(0,s.jsx)(n.h3,{id:"application-class-extending-context",children:"Application Class Extending Context"}),"\n",(0,s.jsx)(n.p,{children:"Create an application class that extends Context as the core of your application:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { Context, injectable } from 'contexify';\n\nexport class MyApplication extends Context {\n  constructor() {\n    super('application');\n  }\n\n  async setup() {\n    // Register core services\n    this.bind('logger').toClass(Logger);\n\n    // Add components\n    this.component(AuthComponent);\n    this.component(ApiComponent);\n\n    // You could perform async initialization here\n    // For example, connecting to databases, loading configurations, etc.\n    await Promise.resolve(); // Placeholder for actual async operations\n\n    console.log('Application setup completed');\n    return this;\n  }\n\n  async start() {\n    // Start the application\n    console.log('Application starting...');\n    // Startup logic...\n  }\n\n  async stop() {\n    // Stop the application\n    console.log('Application stopping...');\n    // Cleanup logic...\n    this.close(); // Close the Context\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"components-and-modular-design",children:"Components and Modular Design"}),"\n",(0,s.jsx)(n.p,{children:"Components are collections of related bindings used to extend application functionality:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { injectable, Binding } from 'contexify';\n\nexport interface Component {\n  bindings?: Binding[];\n  providers?: Constructor<Provider<unknown>>[];\n}\n\n@injectable()\nexport class AuthComponent implements Component {\n  bindings = [\n    createBindingFromClass(AuthService),\n    createBindingFromClass(TokenService),\n  ];\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Using components allows you to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Group related functionality together"}),"\n",(0,s.jsx)(n.li,{children:"Promote modular design"}),"\n",(0,s.jsx)(n.li,{children:"Support a pluggable architecture"}),"\n",(0,s.jsx)(n.li,{children:"Simplify dependency management"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"lifecycle-management",children:"Lifecycle Management"}),"\n",(0,s.jsx)(n.p,{children:"Your application should manage the lifecycle of components and services:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export class MyApplication extends Context {\n  // ...\n\n  async start() {\n    // Get all services that need initialization\n    const initializers = await this.findByTag('initializer');\n\n    // Initialize in sequence\n    for (const initializer of initializers) {\n      const service = await this.get(initializer.key);\n      await service.initialize();\n    }\n\n    console.log('Application started');\n  }\n\n  async stop() {\n    // Get all services that need cleanup\n    const cleaners = await this.findByTag('cleaner');\n\n    // Clean up in sequence\n    for (const cleaner of cleaners) {\n      const service = await this.get(cleaner.key);\n      await service.cleanup();\n    }\n\n    this.close();\n    console.log('Application stopped');\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"dependency-injection-best-practices",children:"Dependency Injection Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"use-decorators-for-dependency-injection",children:"Use Decorators for Dependency Injection"}),"\n",(0,s.jsx)(n.p,{children:"It's recommended to use decorators for dependency injection instead of directly retrieving dependencies from the Context:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { inject, injectable } from 'contexify';\n\n@injectable()\nexport class UserController {\n  constructor(\n    @inject('repositories.UserRepository') private userRepo: UserRepository,\n    @inject('services.EmailService') private emailService: EmailService\n  ) {}\n\n  async createUser(userData: UserData) {\n    const user = await this.userRepo.create(userData);\n    await this.emailService.sendWelcomeEmail(user);\n    return user;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Benefits:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Dependencies are explicit and visible"}),"\n",(0,s.jsx)(n.li,{children:"Easy to test, as dependencies can be mocked"}),"\n",(0,s.jsx)(n.li,{children:"Code is cleaner and more maintainable"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"binding-key-naming-conventions",children:"Binding Key Naming Conventions"}),"\n",(0,s.jsx)(n.p,{children:"Use consistent naming conventions to organize binding keys:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Services\napp.bind('services.EmailService').toClass(EmailService);\n\n// Repositories\napp.bind('repositories.UserRepository').toClass(UserRepository);\n\n// Controllers\napp.bind('controllers.UserController').toClass(UserController);\n\n// Configuration\napp.bind('config.api').to({\n  port: 3000,\n  host: 'localhost',\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"Recommended naming patterns:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"{namespace}.{name}"}),": Use namespace and name"]}),"\n",(0,s.jsx)(n.li,{children:"Use plural forms for namespaces (services, repositories, controllers)"}),"\n",(0,s.jsxs)(n.li,{children:["For configurations, use ",(0,s.jsx)(n.code,{children:"config.{component}"})]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"scope-management",children:"Scope Management"}),"\n",(0,s.jsx)(n.p,{children:"Choose appropriate scopes based on the nature of the component:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { BindingScope } from 'contexify';\n\n// Singleton service\napp\n  .bind('services.ConfigService')\n  .toClass(ConfigService)\n  .inScope(BindingScope.SINGLETON);\n\n// One instance per request\napp\n  .bind('controllers.RequestController')\n  .toClass(RequestController)\n  .inScope(BindingScope.TRANSIENT);\n\n// Singleton in the current context\napp\n  .bind('services.CacheService')\n  .toClass(CacheService)\n  .inScope(BindingScope.CONTEXT);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Scope guidelines:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"SINGLETON"}),": For services with shared state (configurations, database connections)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"TRANSIENT"}),": For components that need a new instance each time they're used"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"CONTEXT"}),": For components shared within a specific context"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"advanced-patterns",children:"Advanced Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"using-interceptors",children:"Using Interceptors"}),"\n",(0,s.jsx)(n.p,{children:"Interceptors allow you to execute code before and after method calls:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { injectable, intercept } from 'contexify';\nimport { LogInterceptor } from './interceptors';\n\n@injectable()\nexport class UserService {\n  @intercept(LogInterceptor)\n  async createUser(userData: UserData) {\n    // Logic to create a user\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Interceptor use cases:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Logging"}),"\n",(0,s.jsx)(n.li,{children:"Performance monitoring"}),"\n",(0,s.jsx)(n.li,{children:"Error handling"}),"\n",(0,s.jsx)(n.li,{children:"Transaction management"}),"\n",(0,s.jsx)(n.li,{children:"Caching"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"using-the-observer-pattern",children:"Using the Observer Pattern"}),"\n",(0,s.jsx)(n.p,{children:"Observe binding changes in the Context:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { ContextObserver } from 'contexify';\n\nexport class ServiceRegistry implements ContextObserver {\n  // Only interested in bindings with 'service' tag\n  filter = (binding) => binding.tagMap.service != null;\n\n  observe(event: string, binding: Binding) {\n    if (event === 'bind') {\n      console.log(`Service registered: ${binding.key}`);\n      // Handle new service\n    } else if (event === 'unbind') {\n      console.log(`Service unregistered: ${binding.key}`);\n      // Clean up service\n    }\n  }\n}\n\n// Register the observer\napp.subscribe(new ServiceRegistry());\n"})}),"\n",(0,s.jsx)(n.p,{children:"Observer use cases:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Dynamic service discovery and registration"}),"\n",(0,s.jsx)(n.li,{children:"Monitoring binding changes"}),"\n",(0,s.jsx)(n.li,{children:"Implementing plugin systems"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"configuration-management",children:"Configuration Management"}),"\n",(0,s.jsx)(n.p,{children:"Use Context's configuration capabilities to manage application configuration:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Register configuration\napp.configure('services.EmailService').to({\n  host: 'smtp.example.com',\n  port: 587,\n  secure: true,\n});\n\n// Use configuration in services\n@injectable()\nexport class EmailService {\n  constructor(@config() private config: EmailConfig) {}\n\n  async sendEmail(options: EmailOptions) {\n    // Access configuration via this.config\n  }\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Configuration best practices:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"configure()"})," and ",(0,s.jsx)(n.code,{children:"@config()"})," instead of hardcoding configuration keys"]}),"\n",(0,s.jsx)(n.li,{children:"Provide default values for configuration"}),"\n",(0,s.jsx)(n.li,{children:"Support environment-specific configuration overrides"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"Best practices for using Context as your application core:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Application extends Context"}),": Let your application class extend Context to serve as a dependency injection container"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use Components for Modularity"}),": Organize related functionality and bindings with components"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dependency Injection over Direct Access"}),": Use ",(0,s.jsx)(n.code,{children:"@inject"})," and other decorators to inject dependencies"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Consistent Naming Conventions"}),": Use consistent naming patterns for binding keys"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Appropriate Scope Management"}),": Choose suitable binding scopes based on component nature"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Leverage Advanced Features"}),": Use interceptors, observers, and configuration management to enhance your application"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"By following these best practices, you can build modular, testable, and maintainable applications that leverage the powerful capabilities of the Contexify framework."})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);